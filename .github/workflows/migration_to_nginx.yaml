name: Migrate to Nginx Ingress Controller

on:
  workflow_dispatch:
    inputs:
      dryrun:
        description: 'Run in dry-run mode (no changes applied)'
        required: true
        default: 'true'
        type: boolean

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_REGION: us-east-1
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}

jobs:
  migrate_to_nginx:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up kubectl
        uses: kodermax/kubectl-aws-eks@master
        
      - name: Verify kubectl connection
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: cluster-info
          
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'

      - name: Check if Nginx Ingress Controller exists
        id: check-nginx
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: get namespace ingress-nginx &>/dev/null && echo "NGINX_EXISTS=true" >> $GITHUB_ENV || echo "NGINX_EXISTS=false" >> $GITHUB_ENV

      - name: Install Nginx Ingress Controller
        if: ${{ github.event.inputs.dryrun == 'false' && env.NGINX_EXISTS == 'false' }}
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: |
            helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx && \
            helm repo update && \
            helm install ingress-nginx ingress-nginx/ingress-nginx \
              --namespace ingress-nginx \
              --create-namespace \
              --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
              --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-ssl-cert"="arn:aws:acm:us-east-1:955116512041:certificate/fa29cb5d-f635-40df-89cc-70db82c93845" \
              --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-ssl-ports"="https" \
              --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-backend-protocol"="ssl" \
              --set controller.service.ports.https=443 \
              --set controller.ingressClassResource.default=true
        
      - name: Check if cert-manager exists
        id: check-cert-manager
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: get namespace cert-manager &>/dev/null && echo "CERT_MANAGER_EXISTS=true" >> $GITHUB_ENV || echo "CERT_MANAGER_EXISTS=false" >> $GITHUB_ENV

      - name: Install cert-manager
        if: ${{ github.event.inputs.dryrun == 'false' && env.CERT_MANAGER_EXISTS == 'false' }}
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: |
            helm repo add jetstack https://charts.jetstack.io && \
            helm repo update && \
            helm install cert-manager jetstack/cert-manager \
              --namespace cert-manager \
              --create-namespace \
              --set installCRDs=true
        
      - name: Create ClusterIssuer for Let's Encrypt
        if: ${{ github.event.inputs.dryrun == 'false' && env.CERT_MANAGER_EXISTS == 'false' }}
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: |
            # Wait for cert-manager to be ready
            sleep 30
            
            # Create temporary file for ClusterIssuer
            cat > /tmp/clusterissuer.yaml << 'EOF'
            apiVersion: cert-manager.io/v1
            kind: ClusterIssuer
            metadata:
              name: letsencrypt-prod
            spec:
              acme:
                server: https://acme-v02.api.letsencrypt.org/directory
                email: admin@launchdarklydemos.com
                privateKeySecretRef:
                  name: letsencrypt-prod
                solvers:
                - http01:
                    ingress:
                      class: nginx
            EOF
            
            # Apply the ClusterIssuer
            kubectl apply -f /tmp/clusterissuer.yaml

      - name: Get Nginx Ingress Controller Hostname
        id: get-nginx-lb
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: |
            if [ "${{ github.event.inputs.dryrun }}" == "false" ]; then
              echo "Getting Nginx Ingress Controller hostname..."
              
              # Check if the ingress-nginx controller service exists
              if kubectl get service -n ingress-nginx ingress-nginx-controller &>/dev/null; then
                echo "Waiting for load balancer to be provisioned..."
                sleep 30
                
                # Get the hostname with retries
                ATTEMPTS=0
                while [ $ATTEMPTS -lt 5 ]; do
                  NGINX_LB_HOSTNAME=$(kubectl get service -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                  if [ ! -z "$NGINX_LB_HOSTNAME" ]; then
                    break
                  fi
                  echo "Waiting for load balancer hostname... (attempt $ATTEMPTS)"
                  sleep 20
                  ATTEMPTS=$((ATTEMPTS + 1))
                done
                
                if [ -z "$NGINX_LB_HOSTNAME" ]; then
                  echo "Could not get hostname yet, using existing ALB temporarily"
                  NGINX_LB_HOSTNAME="k8s-ldcoredemolb-93af62c3af-1176236694.us-east-1.elb.amazonaws.com"
                fi
              else
                echo "Ingress controller not found, using existing ALB"
                NGINX_LB_HOSTNAME="k8s-ldcoredemolb-93af62c3af-1176236694.us-east-1.elb.amazonaws.com"
              fi
              
              echo "NGINX_LB_HOSTNAME=$NGINX_LB_HOSTNAME" >> $GITHUB_ENV
              echo "Using load balancer: $NGINX_LB_HOSTNAME"
            else
              echo "Dry run mode - using placeholder hostname"
              echo "NGINX_LB_HOSTNAME=dryrun.example.com" >> $GITHUB_ENV
            fi

      - name: List all namespaces
        id: list-namespaces
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: |
            # Get all namespaces except system ones
            kubectl get namespaces -o name | grep -v "kube-\|default\|ingress-nginx\|cert-manager" | cut -d/ -f2 > namespaces.txt
            cat namespaces.txt
            echo "Found $(wc -l < namespaces.txt) namespaces to migrate"

      - name: Create migration script
        run: |
          echo '#!/bin/bash
          set -e
          
          NAMESPACE=$1
          NGINX_LB_HOSTNAME=$2
          DRY_RUN=$3
          
          echo "Processing namespace: $NAMESPACE"
          
          # Get the current ingress configuration
          if kubectl get ingress -n $NAMESPACE ld-core-demo-ingress 2>/dev/null; then
            echo "Found existing ingress in namespace $NAMESPACE"
            
            # Create the new ingress yaml
            cat > /tmp/$NAMESPACE-ingress.yaml << EOF
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ld-core-demo-ingress
            namespace: $NAMESPACE
            annotations:
              kubernetes.io/ingress.class: nginx
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
              nginx.ingress.kubernetes.io/use-regex: "true"
              nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
              nginx.ingress.kubernetes.io/proxy-ssl-verify: "off"
              cert-manager.io/cluster-issuer: "letsencrypt-prod"
          spec:
            tls:
            - hosts:
              - $NAMESPACE.launchdarklydemos.com
              secretName: $NAMESPACE-tls
            rules:
              - host: $NAMESPACE.launchdarklydemos.com
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: $NAMESPACE
                          port:
                            number: 443
          EOF
            
            # Update the service type if needed
            if kubectl get service -n $NAMESPACE $NAMESPACE 2>/dev/null; then
              echo "Found service $NAMESPACE in namespace $NAMESPACE"
              
              SERVICE_TYPE=$(kubectl get service -n $NAMESPACE $NAMESPACE -o jsonpath="{.spec.type}")
              if [ "$SERVICE_TYPE" == "NodePort" ]; then
                echo "Updating service from NodePort to ClusterIP"
                
                if [ "$DRY_RUN" == "false" ]; then
                  kubectl patch service -n $NAMESPACE $NAMESPACE -p "{\"spec\":{\"type\":\"ClusterIP\"}}"
                else
                  echo "DRY RUN: Would update service $NAMESPACE from NodePort to ClusterIP"
                fi
              fi
            else
              echo "Service $NAMESPACE not found in namespace $NAMESPACE"
            fi
            
            # Apply the new ingress configuration
            if [ "$DRY_RUN" == "false" ]; then
              kubectl apply -f /tmp/$NAMESPACE-ingress.yaml
              echo "Updated ingress for namespace $NAMESPACE"
            else
              echo "DRY RUN: Would apply the following ingress:"
              cat /tmp/$NAMESPACE-ingress.yaml
            fi
            
            # Update DNS record
            if [ "$DRY_RUN" == "false" ]; then
              HOSTED_ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name "launchdarklydemos.com." --query "HostedZones[0].Id" --output text)
              
              cat > /tmp/$NAMESPACE-route53.json << EOF
          {
            "Comment": "Updating Alias record to point to Nginx Ingress Controller",
            "Changes": [
              {
                "Action": "UPSERT",
                "ResourceRecordSet": {
                  "Name": "'$NAMESPACE'.launchdarklydemos.com",
                  "Type": "A",
                  "AliasTarget": {
                    "HostedZoneId": "Z35SXDOTRQ7X7K",
                    "DNSName": "'$NGINX_LB_HOSTNAME'",
                    "EvaluateTargetHealth": false
                  }
                }
              }
            ]
          }
          EOF
              
              aws route53 change-resource-record-sets --hosted-zone-id $HOSTED_ZONE_ID --change-batch file:///tmp/$NAMESPACE-route53.json
              echo "Updated DNS for $NAMESPACE.launchdarklydemos.com to point to $NGINX_LB_HOSTNAME"
            else
              echo "DRY RUN: Would update DNS for $NAMESPACE.launchdarklydemos.com to point to $NGINX_LB_HOSTNAME"
            fi
          else
            echo "No ingress found in namespace $NAMESPACE, skipping..."
          fi' > migrate_namespace.sh
          
          chmod +x migrate_namespace.sh

      - name: Execute migration for each namespace
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: |
            while read NAMESPACE; do
              echo "Processing namespace: $NAMESPACE"
              bash ./migrate_namespace.sh "$NAMESPACE" "${{ env.NGINX_LB_HOSTNAME }}" "${{ github.event.inputs.dryrun }}"
            done < namespaces.txt
            
            echo "Migration completed."
            if [ "${{ github.event.inputs.dryrun }}" == "false" ]; then
              echo "Please verify the migrated environments are accessible via their URLs."
            else
              echo "This was a dry run. No changes were made."
            fi