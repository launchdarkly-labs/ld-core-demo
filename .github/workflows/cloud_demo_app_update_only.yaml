name: Cloud Demo App Update Only

on:
  workflow_dispatch:
    inputs:
      name:
        description: 'Username'
        required: true

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_REGION: us-east-1
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}
  ECR_REPOSITORY: ld-core-demo
  KUBECTL_VERSION: "v1.23.0"
  DEMO_NAMESPACE: ${{ github.event.inputs.name }}
  LD_PROJECT_KEY: ${{ github.event.inputs.name }}-ld-demo
  LD_API_KEY: ${{ secrets.LD_EAP_API_KEY }}

jobs:
  provisioning_demo_environment:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: "3.9"

      - name: Install LaunchDarkly CLI
        run: |
          npm install -g @launchdarkly/ldcli
          ldcli config --set access-token ${{ secrets.LD_EAP_API_KEY }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r ./.github/workflows/demo_provisioning_scripts/requirements.txt

      - name: Get LaunchDarkly Project
        id: ld_project_setup
        run: |
          echo "Getting LaunchDarkly project for namespace: ${{ env.DEMO_NAMESPACE }}"
          ldcli environments get --project ${{ env.LD_PROJECT_KEY }} --environment production -o json > ld_project.json

      - name: Parse LaunchDarkly Project JSON
        id: parse_ld_project
        run: |
          apiKey=$(jq -r '.apiKey' ld_project.json)
          id=$(jq -r '._id' ld_project.json)
          echo "LD_SDK_KEY=$apiKey" >> $GITHUB_ENV
          echo "LD_CLIENT_KEY=$id" >> $GITHUB_ENV

      - name: Create .env file for demo pod
        run: |
          touch ./.env.production
          echo NEXT_PUBLIC_LD_CLIENT_KEY=${{ env.LD_CLIENT_KEY }} >> ./.env.production
          echo LD_SDK_KEY=${{ env.LD_SDK_KEY }} >> ./.env.production
          echo DB_URL=${{ secrets.DB_URL }} >> ./.env.production
          echo LD_API_KEY=${{ env.LD_API_KEY }} >> ./.env.production
          echo DESTINATIONENV=production >> ./.env.production
          echo PROJECT_KEY=${{ env.LD_PROJECT_KEY }} >> ./.env.production
          echo AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY }} >> ./.env.production
          echo AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }} >> ./.env.production

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      # - name: Build, tag, and push image to Amazon ECR
      #   env:
      #     ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      #     ECR_REPOSITORY: ld-core-demo
      #   run: |
      #     docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.DEMO_NAMESPACE }}-${{ github.run_id }} .
      #     docker push $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.DEMO_NAMESPACE }}-${{ github.run_id }}

      - name: Update K8s Deploy File
        run: python ./.github/workflows/update_k8s_deploy_file.py
        env:
          NAMESPACE: ${{ env.DEMO_NAMESPACE }}
          URL: ${{ env.DEMO_NAMESPACE }}.launchdarklydemos.com
          IMAGE: ${{ steps.login-ecr.outputs.registry }}/ld-core-demo:${{ env.DEMO_NAMESPACE }}-${{ github.run_id }}

      - name: Check Namespace in Kubernetes
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: get namespace ${{ env.DEMO_NAMESPACE }} &>/dev/null && echo "namespace_exists=true" >> $GITHUB_ENV || echo "namespace_exists=false" >> $GITHUB_ENV

      - name: Create Namespace In Kubernetes
        if: env.namespace_exists == 'false'
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: create namespace ${{ env.DEMO_NAMESPACE }}

      - name: Applying deploy file to Kubernetes
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: apply -f ./.github/workflows/deploy_files/deploy.yaml -n ${{ env.DEMO_NAMESPACE }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Get NGINX Ingress Controller Load Balancer IP
        id: get-nginx-lb
        uses: kodermax/kubectl-aws-eks@master
        with:
          args: get service -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' > hostname.txt && echo "NGINX_LB_HOSTNAME=$(cat hostname.txt)" >> $GITHUB_ENV

      - name: Delete existing Route 53 Record
        run: |
          echo "DEMO_NAMESPACE=${{ env.DEMO_NAMESPACE }}" >> $GITHUB_ENV
          HOSTED_ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name "launchdarklydemos.com." --query "HostedZones[0].Id" --output text)
          echo "HOSTED_ZONE_ID=$HOSTED_ZONE_ID" >> $GITHUB_ENV
          RECORD_NAME="${DEMO_NAMESPACE}.launchdarklydemos.com"
          echo "RECORD_NAME=$RECORD_NAME" >> $GITHUB_ENV

          # Check if record exists
          RECORD_EXISTS=$(aws route53 list-resource-record-sets --hosted-zone-id "$HOSTED_ZONE_ID" --query "ResourceRecordSets[?Name=='${RECORD_NAME}.']" --output text)

          if [ -n "$RECORD_EXISTS" ]; then
            echo "Existing record found. Getting details for deletion..."

            # Get the record details using jq
            aws route53 list-resource-record-sets --hosted-zone-id "$HOSTED_ZONE_ID" \
              --query "ResourceRecordSets[?Name=='${RECORD_NAME}.']" --output json > record.json

            RECORD_TYPE=$(jq -r '.[0].Type' record.json)
            RECORD_TTL=$(jq -r '.[0].TTL // 300' record.json)
            RECORD_VALUE=$(jq -r '.[0].ResourceRecords[0].Value' record.json)
            echo "RECORD_TYPE=$RECORD_TYPE" >> $GITHUB_ENV
            echo "RECORD_TTL=$RECORD_TTL" >> $GITHUB_ENV
            echo "RECORD_VALUE=$RECORD_VALUE" >> $GITHUB_ENV

            # Create deletion JSON
            DELETE_JSON=$(cat <<EOF
{
  "Changes": [
    {
      "Action": "DELETE",
      "ResourceRecordSet": {
        "Name": "${RECORD_NAME}",
        "Type": "${RECORD_TYPE}",
        "TTL": ${RECORD_TTL},
        "ResourceRecords": [
          {
            "Value": "${RECORD_VALUE}"
          }
        ]
      }
    }
  ]
}
EOF
)

            echo "Deleting DNS record: $RECORD_NAME"
            aws route53 change-resource-record-sets \
              --hosted-zone-id "$HOSTED_ZONE_ID" \
              --change-batch "$DELETE_JSON"

            echo "Record deletion completed"
          else
            echo "No existing record found for $RECORD_NAME"
          fi
        env:
          AWS_REGION: us-east-1

      - name: Add Route 53 Record
        run: |
          # Use GitHub env for variables
          echo "DEMO_NAMESPACE=${{ env.DEMO_NAMESPACE }}" >> $GITHUB_ENV
          echo "NGINX_LB_HOSTNAME=${{ env.NGINX_LB_HOSTNAME }}" >> $GITHUB_ENV
          HOSTED_ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name "launchdarklydemos.com." --query "HostedZones[0].Id" --output text)
          echo "HOSTED_ZONE_ID=$HOSTED_ZONE_ID" >> $GITHUB_ENV

          RECORD_SET_JSON=$(cat <<EOF
{
  "Comment": "Creating CNAME record that points to NGINX Ingress Controller LB",
  "Changes": [
    {
      "Action": "UPSERT",
      "ResourceRecordSet": {
        "Name": "${DEMO_NAMESPACE}.launchdarklydemos.com",
        "Type": "CNAME",
        "TTL": 300,
        "ResourceRecords": [
          {
            "Value": "${NGINX_LB_HOSTNAME}"
          }
        ]
      }
    }
  ]
}
EOF
)

          aws route53 change-resource-record-sets \
            --hosted-zone-id "$HOSTED_ZONE_ID" \
            --change-batch "$RECORD_SET_JSON"
        env:
          AWS_REGION: us-east-1

      - name: Delete the deploy file
        run: rm -rf ./.github/workflows/deploy_files

      - name: Remove .env file
        run: rm ./.env.production